// buncha funky vars going on here. have some defines

/// Block gases, both atmospheric and chemsmoke
#define SHIELD_BLOCK_GAS 1
/// Block liquids and gases
#define SHIELD_BLOCK_FLUID 2
/// Block everything; functionally a wall of energy
#define SHIELD_BLOCK_ALL 3

// For the orientation
#define VERTICAL 0
#define HORIZONTAL 1
/obj/machinery/shieldgenerator/energy_shield
	name = "Energy-Shield Generator"
	desc = "Solid matter can pass through the shields generated by this generator."
	icon = 'icons/obj/meteor_shield.dmi'
	icon_state = "energyShield"
	density = FALSE
	var/orientation = HORIZONTAL  //shield extend direction 0 = north/south, 1 = east/west
	power_level = SHIELD_BLOCK_GAS //1 for atmos shield, 2 for liquid, 3 for solid material
	var/max_power = SHIELD_BLOCK_ALL
	var/min_power = SHIELD_BLOCK_GAS
	min_range = 1
	max_range = 4
	direction = "dir"
	layer = OBJ_LAYER

	New()
		..()
		display_active.icon_state = "energyShieldOn"
		src.power_usage = 5

	get_desc(dist, mob/user)
		..()
		var/charge_percentage = 0
		if (PCEL?.charge > 0 && PCEL.maxcharge > 0)
			charge_percentage = round((PCEL.charge/PCEL.maxcharge)*100)
			. += "It has [PCEL.charge]/[PCEL.maxcharge] ([charge_percentage]%) battery power left."
		else
			. += "It seems to be missing a usable battery."
		. += "The unit will consume [10 * src.range * (src.power_level * src.power_level)] power a second."
		. += "The range setting is set to [src.range]."
		. += "The power setting is set to [src.power_level]."

	shield_on()
		if (!PCEL)
			if (!powered()) //if NOT connected to power grid and there is power
				src.power_usage = 0
				return
			else //no power cell, not connected to grid: power down if active, do nothing otherwise
				src.power_usage = 10 * (src.range) * (power_level * power_level)
				generate_shield()
				return
		else
			if (PCEL.charge > 0)
				generate_shield()
				return

	pulse(var/mob/user)
		if(active)
			boutput(user, "<span class='alert'>You can't change the power level or range while the generator is active.</span>")
			return
		var/list/choices = list("Set Range")
		if(max_power != min_power)
			choices += "Set Power Level"
		var/input
		if(length(choices) == 1)
			input = choices[1]
		else
			input = input("Select a config to modify!", "Config", null) as null|anything in choices
		if(input && (user in range(1,src)))
			switch(input)
				if("Set Range")
					src.set_range(user)
				if("Set Power Level")
					var/the_level = input("Enter a power level from [src.min_power]-[src.max_power]. Higher levels use more power.","[src.name]",1) as null|num
					if(!the_level)
						return
					if(BOUNDS_DIST(user, src) > 0)
						boutput(user, "<span class='alert'>You flail your arms at [src] from across the room like a complete muppet. Move closer, genius!</span>")
						return
					the_level = clamp(the_level, min_power, max_power)
					src.power_level = the_level
					boutput(user, "<span class='notice'>You set the power level to [src.power_level].</span>")

	//Code for placing the shields and adding them to the generator's shield list
	proc/generate_shield()
		update_orientation()
		var/xa= -range-1
		var/ya= -range-1
		var/turf/T
		if (range == 0)
			var/obj/forcefield/energyshield/S = new /obj/forcefield/energyshield(get_turf(src))
			S.icon_state = "enshieldw"
			src.deployed_shields += S
		else
			for (var/i = 0-range, i <= range, i++)
				if (orientation)
					T = locate((src.x+i),(src.y),src.z)
					xa++
					ya = 0
				else
					T = locate((src.x),(src.y+i), src.z)
					ya++
					xa = 0

				if (src.checkForcefieldAllowed(T))
					createForcefieldObject(xa, ya);

		src.anchored = TRUE
		src.active = TRUE

		// update_nearby_tiles()
		playsound(src.loc, src.sound_on, 50, 1)
		if (src.power_level == 1)
			display_active.color = "#0000FA"
		else if (src.power_level == 2)
			display_active.color = "#00FF00"
		else
			display_active.color = "#FA0000"
		build_icon()

	//Changes shield orientation based on direction the generator is facing
	proc/update_orientation()
		if (src.dir == NORTH || src.dir == SOUTH)
			orientation = VERTICAL
		else
			orientation = HORIZONTAL

	//this is so long because I wanted the tiles to look like one seamless object. Otherwise it could just be a single line
	proc/createForcefieldObject(xa, ya, turf/T)
		if(isnull(T))
			T = locate((src.x + xa), (src.y + ya), src.z)
		var/obj/forcefield/energyshield/S = new /obj/forcefield/energyshield(T, src, TRUE)
		S.layer = 2
		src.deployed_shields += S
		return S

	/// Proc to check if it's valid to place a force field on a given tile.
	/// Checks for turf density, then blocking objects; however, we ignore ON_BORDER objects such as railings
	/// Mobs are not considered.
	proc/checkForcefieldAllowed(var/turf/T)
		. = FALSE
		if (T.density)
			return
		for (var/obj/O in T) // don't care about mobs
			if (!O.Cross())
				if (O.flags & ON_BORDER) // it's a railing or some shit, we can ignore
					continue
				return // something dense or otherwise uncrossable, no dice
		return TRUE



/obj/machinery/shieldgenerator/energy_shield/botany
	name = "smoke shield generator"
	icon_state = "botanygen"
	desc = "For all your hotboxing needs."
	density = FALSE
	min_power = SHIELD_BLOCK_GAS
	max_power = SHIELD_BLOCK_GAS

	update_orientation()
		orientation = VERTICAL

	generate_shield()
		for(var/turf/T in orange(src, range))
			if(GET_DIST(T, src) != range)
				continue
			if (!T.density && !T.gas_impermeable)
				var/obj/forcefield/energyshield/shield = createForcefieldObject(T=T)
				animate(shield, time=5 SECONDS, loop=-1, easing=SINE_EASING, color="#88FF00")
				animate(time=5 SECONDS, loop=-1, easing=SINE_EASING, color="#0088FF")

		src.anchored = TRUE
		src.active = TRUE

		playsound(src.loc, src.sound_on, 50, 1)
		display_active.color = "#00FF00"
		build_icon()

#undef SHIELD_BLOCK_GAS
#undef SHIELD_BLOCK_FLUID
#undef SHIELD_BLOCK_ALL

#undef VERTICAL
#undef HORIZONTAL
