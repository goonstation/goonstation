
// lets see if this makes ends up any sense wheeeeeee
// god help my newbie coder soul


/datum/phone
	var/atom/holder = null // the atom we belong to; set type in child datum so you can call necessary procs
	var/phoneName = null // This is the name the user will see when we're displayed in a contact list
	var/phoneNumber = null // unique identifier for our phone. doubles as a way to directly try and contact a phone
	var/formattedPhoneNumber = null // string version of phone number in xxx-xxxx format. mostly just for displaying to users
	var/static/phoneNumberHash[9999999] // stores all phone numbers in every phone datum; used for quickly accessing phone number and associated phone
	var/phoneCallType = /datum/phonecall // override var for your phone datum to generate a different phonecall datum

	var/unlisted = FALSE
	var/maxConnected = 1 // limit of how many contacts can be in a phonecall with us, not including us
	var/prioritizeOurMax = FALSE // if TRUE other phones will ignore their maxConnected when they try to join a phonecall we're hosting

	var/dialledNumber = "" // used by the dialpad to store user input
	var/static/keyTones = list( // Keys and their tone sound .oggs; also doubles as input validation.
		"0" = 'sound/machines/phones/DTMF/DTMF-0.ogg',
		"1" = 'sound/machines/phones/DTMF/DTMF-1.ogg',
		"2" = 'sound/machines/phones/DTMF/DTMF-2.ogg',
		"3" = 'sound/machines/phones/DTMF/DTMF-3.ogg',
		"4" = 'sound/machines/phones/DTMF/DTMF-4.ogg',
		"5" = 'sound/machines/phones/DTMF/DTMF-5.ogg',
		"6" = 'sound/machines/phones/DTMF/DTMF-6.ogg',
		"7" = 'sound/machines/phones/DTMF/DTMF-7.ogg',
		"8" = 'sound/machines/phones/DTMF/DTMF-8.ogg',
		"9" = 'sound/machines/phones/DTMF/DTMF-9.ogg',
		"#" = 'sound/machines/phones/DTMF/DTMF-pound.ogg',
		"∗" = 'sound/machines/phones/DTMF/DTMF-star.ogg'
	) // DTMF tones generated by Audacity
	var/lastDial = 0 // used for dialpad cooldown

	var/datum/phonecall/incomingCall // who's calling us???
	var/datum/phonecall/currentPhoneCall = null

	var/canVoltron = FALSE
	var/canVape = FALSE // you better make this true when possible, dweeb
	var/canTalkAcrossZLevels = FALSE

	// These vars are for enabling or disabling certain elements of the UI, such as hangup buttons
	var/elementSettings = list(
		"hangupButton" = FALSE,
		"groupCallControl" = FALSE,
		"contactPanel" = TRUE,
		"dialPad" = TRUE,
		"dialScreen" = TRUE
	)

	// Default sounds, override at your leisure
	var/sound/dialtone = 'sound/machines/phones/phone_busy.ogg'
	var/sound/diallingSound = 'sound/machines/phones/dial.ogg'

	/// Call as New(src)
	New(var/atom/creator)
		..()
		holder = creator // phoneName should be assigned elsewhere or by just overriding the var
		generatePhoneNumber()
		START_TRACKING

	disposing()
		STOP_TRACKING
		..()

	/// Handles joining *and* inviting to phonecalls, and creating them as necessary. toCall may be a phone datum, a phone number, or a list of either or both
	proc/startPhoneCall(var/toCall, var/forceStart, var/doGroupCall = FALSE)
		if(currentPhoneCall)
			if(forceStart)
				disconnectFromCall()
			else if(!currentPhoneCall.isGroupCall && (currentPhoneCall.host != src))
				return FALSE

		if(!toCall && !forceStart)
			return FALSE // forceStart will let us start an empty call if need be, even if we don't have a target or our target is invalid

		toCall = validatePhones(toCall)

		var/joinCallAttempt = tryJoinGroup(toCall, doGroupCall)
		if(!isnull(joinCallAttempt)) // only null if we aren't joining a valid group call, but if we are we return whether or not it was successful
			return joinCallAttempt ? TRUE : FALSE

		if(!currentPhoneCall) // if it's not an existing call we make a new one
			currentPhoneCall = new phoneCallType(src, maxConnected, prioritizeOurMax, doGroupCall)

		. += inviteToCall(toCall)  // we can to let our proc caller know if we're successfully ringing them or not, and how many people we were able to start ringing
		if(!.)
			callFailed()


	/// Handles logic for if we should join a group call when we attempt to call a single phone; if they are a group call's host, this proc will by default request to join their group call
	proc/tryJoinGroup(var/call_list, var/doGroupCall)
		. = null // We return null if the phone we're calling isn't even a host and we should move to the next step in startPhoneCall. This is redundant but helps to illustrate what we're doing
		if(islist(call_list) || doGroupCall)
			return
		var/datum/phone/target = call_list
		if(!istype(target, /datum/phone))
			return
		if(!target.currentPhoneCall?.isGroupCall)
			return
		if(target.currentPhoneCall?.host != target)
			return

		. = FALSE // FALSE and not null because by this point we're now certain on what we wanna do, which is to join this call
		if(!target.receiveJoinCallRequest(src))
			return
		var/datum/phonecall/targetCall = target.currentPhoneCall
		if(joinPhoneCall(targetCall))
			return TRUE // yay we joined the call!!!


	/// Calls either denyPhoneCall() or disconnectFromCall(); useful for if you just wanna cut all connections immediately. Also clears the dialled number
	proc/hangUp()
		incomingCall?.callDenied(src)
		disconnectFromCall()
		dialledNumber = ""


	/// Rejects an incoming phone call and alerts the phonecall datum of this
	proc/denyPhoneCall(var/datum/phonecall/targetPhoneCall)
		incomingCall.callDenied(src)


	/// Called when we're hosting a phone call and someone denies our invitation (very rude). Or maybe their line was just busy.
	proc/callFailed(var/datum/phone/denyingPhone) // no need to reference the phonecall when we're hosting it (if it exists), but it might be helpful to know who denied the call, if applicable
		if(currentPhoneCall?.isGroupCall)
			return
		handleSound(dialtone,50,0)


	/// For if you wish to cancel someone's invite to your call; particularly useful for group calls
	proc/cancelInvite(var/datum/phone/target)
		if(isnull(target.incomingCall) || (target.incomingCall != currentPhoneCall)) // avoids this somehow proc'ing when both are null. somehow.
			return
		target.incomingCall = null
		target.onInviteCancelled(src)

	proc/onInviteCancelled(var/datum/phone/canceller)


	/// Proc'd when a phone wants to join a call this phone is hosting. By default it accepts their request. Does NOT handle logic for if they can actually join, only if you want them to
	proc/receiveJoinCallRequest(var/datum/phone/source)
		return TRUE


	/// Signals to a datum/phonecall that we'd like to join the phonecall
	proc/joinPhoneCall(var/datum/phonecall/targetPhoneCall)
		if(currentPhoneCall)
			return
		targetPhoneCall.tryConnect(src)


	/// Procs whenever we successfully join a call
	proc/onJoin(var/datum/phonecall/joinedPhoneCall)
		currentPhoneCall = joinedPhoneCall
		incomingCall = null
		return


	/// Procs whenever a phone joins a call we're in
	proc/onRemoteJoin(var/datum/phone/connectedPhone)


	/// Signals to a datum/phonecall that we'd like to leave our current phonecall; aka we're hanging up
	proc/disconnectFromCall()
		currentPhoneCall?.disconnect(src)


	/// Procs whenever we're disconnected from our current call or an incoming one
	proc/onDisconnect(var/datum/phonecall/leftPhoneCall)
		currentPhoneCall = null
		incomingCall = null


	/// Procs whenever someone leaves a call we're in; NOT when they deny the call, but when they hang up
	proc/onRemoteDisconnect(var/datum/phone/disconnectedPhone)


	// Ripped straight from obj/item/proc/talk_into(), hopefully contains enough information for a wide variety of override cases
	proc/sendSpeech(mob/M as mob, text, secure, real_name, lang_id)
		if(!currentPhoneCall)
			return
		currentPhoneCall.relaySpeech(src, M, text, secure, real_name, lang_id)


	/// Called by currentPhoneCall whenever it's relaying speech to us. Override in child proc to make this actually do something
	proc/speechReceived(var/datum/phone/source, mob/M as mob, text, secure, real_name, lang_id)


	/// You need to override this in your child phone datum to actually play sound. All attempts by this datum to play sound will route through here.
	proc/handleSound(soundin, vol as num, vary, extrarange as num, pitch, ignore_flag = 0, channel = VOLUME_CHANNEL_GAME, flags = 0)
		return // Functions identically to playsound(), save for lack of source



	/// Returns a list of phone addresses that we can see in our contact list. By default will just display all phones that aren't Unlisted
	proc/getContacts()
		var/contacts = list()
		for (var/datum/phone/P in by_type[/datum/phone])
			if (P.canSee(src) && (P != src))
				contacts += P // we ask P if we can contact it
		return contacts


	/// Used by getContacts() to determine whether or not it should include this phone address in its return statement. queryingPhone for potential override usage
	proc/canSee(var/datum/phone/queryingPhone)
		. = !unlisted && !qdeled && !holder.qdeled


	/// Called by receiveInvite() to see if queryingPhone should be able to try and call us, even if it entered our phone number directly.
	proc/canCallUs(var/datum/phone/queryingPhone)
		. = !qdeled && !holder.qdeled


	/// Returns the same list as getContacts() except instead of refs its the phones' phoneName associated with phone number. Yes it's a lengthy proc name fuck you.
	proc/getContactNumberToNameList()
		var/list/L = new()
		for(var/datum/phone/contact in getContacts())
			var/textNumber = num2text(contact.phoneNumber, 7)
			L += textNumber
			L[textNumber] = contact.phoneName
		return L


	/// Handles logic needed for inviting a target phone to a call, whether it be a group call or not
	proc/inviteToCall(var/target)
		if(!istype(target, /datum/phone) && !islist(target))
			return FALSE
		if(islist(target))
			var/list/target_list = target
			. = FALSE // we let the proc that called us know if someone was successfully invited or not
			for(var/datum/phone/targetPhone in target_list)
				if(targetPhone.receiveInvite(src, currentPhoneCall))
					currentPhoneCall.pendingMembers += target
					. = TRUE
			return
		else
			var/datum/phone/targetPhone = target
			if(targetPhone.receiveInvite(src, currentPhoneCall))
				currentPhoneCall.pendingMembers += target
				return TRUE
		return FALSE


	/// Handles logic needed for when we receive an invitation to a call. If you override, make sure it will return TRUE or FALSE if the invitation was successful or not.
	proc/receiveInvite(var/datum/phone/caller, var/datum/phonecall/pendingCall)
		if(incomingCall || currentPhoneCall)
			return FALSE
		if(!canCallUs(caller))
			return FALSE
		incomingCall = pendingCall
		return TRUE





	ui_interact(mob/user, datum/tgui/ui)
		ui = tgui_process.try_update_ui(user, src, ui)
		if(!ui)
			ui = new(user, src, "PhoneDefault")
			ui.open()

	ui_data(mob/user)
		var/contactList = getContactNumberToNameList()
		var/list/contacts = list()
		for(var/number in contactList)
			var/name = contactList[number] // we build a list of associative lists so js can keep track of which id goes with which name
			contacts += list(list("phoneNumber" = number, "name" = name))
		. = list(
			"contactList" = contacts,
			"phoneCallMembers" = currentPhoneCall?.members,
			"pendingCallMembers" = currentPhoneCall?.pendingMembers,
			"callHost" = currentPhoneCall?.host,
			"phonecallID" = currentPhoneCall?.phonecallID,
			"elementSettings" = elementSettings,
			"dialledNumber" = dialledNumber)

	ui_host()
		return holder

	ui_act(action, params)
		. = ..()
		if (.)
			return
		switch(action)
			if("makeCall")
				var/trueNumber = text2num_safe(params["target"])
				var/datum/phone/contact = tryGetPhoneFromNumber(trueNumber)
				if(!contact)
					callFailed()
					return
				// as a note, inviteToCall already includes checks for if we can even call them in the first place; no checks needed here
				startPhoneCall(contact)
			if("leaveCall")
				disconnectFromCall()
			if("dialpad")
				handleDialPad(params["text"])
				. = TRUE // we wanna make the dialpad responsive!


	proc/tryGetPhoneFromNumber(var/number)
		if(!(number >= 1000000) || !(number <= 9999999)) // we use ! here to make triple certain it's an actual number in the valid number range even if it's null or something
			return FALSE
		return phoneNumberHash[number]


	/// Handles dial pad operation. Default logic: If dialled key was not a #, add key to dialledNumber. If #, set dialledNumber to "", if no *, call specified number even if mid-call, and if *, return TRUE
	proc/handleDialPad(key)
		if((lastDial + 0.2 SECONDS) > world.time) // 0.2s because that's the length of a single dial tone
			return
		lastDial = world.time
		key2SoundOutput(key)
		if(key != "#")
			dialledNumber += key
			return
		else if(!findtextEx(dialledNumber, "∗"))
			var/trueDialledNumber = text2num_safe(dialledNumber)
			dialledNumber = "" // we reset it because the user hit #
			startPhoneCall(trueDialledNumber, forceStart = TRUE)
		else if(currentPhoneCall || incomingCall)
			hangUp()
		else
			dialledNumber = "" // we reset it because the user hit #
			return TRUE // we return TRUE so you can continue from here by doing if(..()) or something, if you wanna use * commands or whatever, you fucking nerd


	/// Attempts to play a sound based on the key the user pressed
	proc/key2SoundOutput(key)
		if(!(key in keyTones))
			return
		var/sound/tone = keyTones[key]
		handleSound(tone, 30, 0)
		return TRUE // for proc overrides if you wish to do something else when a button is successfully pressed


	/// Called whenever someone in a call we're in hits a dial button; used for any advanced commands/functions you may wanna add
	proc/receiveDial(source, key)


	/// Will take any input and output any valid phone datums it finds in a list; accepts lists and single vars of phone datums or phone numbers in both numerical and string form
	proc/validatePhones(var/input)
		var/toValidateList = list(input)
		var/returnList = list()
		for(var/toValidate in toValidateList)
			if(istype(toValidate, /datum/phone))
				returnList += toValidate
			else if(text2num_safe(toValidate))
				toValidate = text2num_safe(toValidate)
			if(isnum(toValidate))
				if((0 < toValidate) && (toValidate <= 9999999))
					var/target = phoneNumberHash[toValidate]
					if(target)
						returnList += target
		return returnList // lets us slap validatePhones into a for loop since it still parses empty lists

	/// Generates a unique 7 digit phone number and automatically logs it in the phone number hash
	proc/generatePhoneNumber()
		var/testNumber
		do
			testNumber = rand(1000000, 9999999) // guaranteed to never start with a 0 because that'd cause some real fuckery
		while(phoneNumberHash[testNumber]) // literally 1 in 9 million odds to get a duplicate but just in case

		phoneNumberHash[testNumber] = src
		phoneNumber = testNumber
		formattedPhoneNumber = splicetext(text2num(phoneNumber, 7), 4, 4, "-")


	/// Handles what should happen when someone vapes through us. You might need to override this to change *where* the vape comes from, if holder is something like a pda module
	proc/onVape(var/datum/reagents/_buffer, var/obj/item/reagent_containers/vape/vape, var/mob/living/sourceMob, var/datum/phone/sourcePhone)
		smoke_reaction(_buffer, vape.range, get_turf(holder))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, NORTH))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, SOUTH))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, EAST))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, WEST))
		SPAWN_DBG(0) //vape is just the best for not annoying crowds I swear
			vape.smoke.start()
			sleep(1 SECOND)
		//Sample text for what you might wanna use for your proc override
		//boutput(user,"<span class='alert'><B>[sourceMob] blows a cloud of smoke right through the phone! What a total [pick("dork","loser","dweeb","nerd","useless piece of shit","dumbass")]!</B></span>")


	/// Handles final check for if someone can voltron to us once we've been targetted for it - checks for canVoltron already have been done by the point this is intended to be called. Returns whatever atom the person will visibly emerge from.
	proc/onVoltron(var/mob/living/sourceMob, var/obj/item/device/voltron/voltron, var/datum/phone/sourcePhone, var/isOrgan = FALSE, var/override) // isOrgan for if a mishap occured; an organ will be emerging, not a person
		if(isnull(override)) //if you called ..() with override you can still safely call ..()
			. = holder
		else
			. = override
		var/turf/sourceTurf = get_turf(sourceMob)
		var/turf/targetTurf = get_turf(.)
		if((isrestrictedz(sourceTurf.z) || isrestrictedz(targetTurf.z)) && !isOrgan)
			. = FALSE // we can shoot our organs across restricted z levels, which is a win i guess??





// Be careful overriding this too much, make sure you account for other phone datums that may try to connect to this!
/// Handles routing all the speech, data, and members in a phone call
/datum/phonecall
	var/doCustomNew = FALSE // if you wanna override New() then set this to true; ..() will only call the parent ..() in this case
	var/disposing = FALSE

	var/phonecallID = null // in case someone needs to refer to a specific call in a UI, we'll have a unique ID for it

	var/members = list() // Support for 3+ contact calls! Number of connected phones is capped by maxMembers
	var/pendingMembers = list() // sometimes it's useful to know who's being rung up but hasn't connected yet
	var/datum/phone/host = null // who's hosting this party?!

	var/maxMembers = null // how many people can be in this call?
	var/overrideMax = FALSE // if true, phones will ignore their maxMembers value
	var/isGroupCall = null // we can see our host's call max but what if they don't want to do a group call?
	var/allowJoinRequests = FALSE // can people join without an invite?


	New(creator, max, priority, groupCall)
		..()
		initializeVars(creator, max, priority, groupCall)


	/// Override this instead of New()
	proc/initializeVars(creator, max, priority, groupCall)
		host = creator
		maxMembers = max
		overrideMax = priority
		isGroupCall = groupCall
		phonecallID = format_net_id("\ref[src]")


	disposing()
		disposing = TRUE
		var/allMembers = members + pendingMembers
		for(var/datum/phone/contact in allMembers)
			disconnect(contact)
		disconnect(host)
		..()



	/// Handles logic for when a phone agrees to an invitation to this call
	proc/tryConnect(var/datum/phone/target)
		if(length(members) > maxMembers)
			return FALSE
		if((length(members) > target.maxConnected) && !overrideMax)
			return FALSE
		if(target in members)
			return FALSE
		if((src != target.currentPhoneCall) && !isnull(target.currentPhoneCall))
			return FALSE
		members += target
		pendingMembers -= target
		target.onJoin(src)
		for(var/datum/phone/member in members)
			member.onRemoteJoin(target)
		host.onRemoteJoin(target)
		return TRUE


	/// Handles logic for when a phone in pendingMembers denies our call
	proc/callDenied(var/datum/phone/denyingPhone)
		host.callFailed(denyingPhone)
		disconnect(denyingPhone)


	/// Handles logic for what we should do when a phone wants to disconnect from the call
	proc/disconnect(var/datum/phone/target)
		if(isnull(target) || (!(target in members) && !(target in pendingMembers) && target != host))
			return
		target.onDisconnect(src) // we let them know what /phonecall datum is calling this proc, just in case an override wants to use it
		if(host == target)
			host = null // we set this now so that when we call dispose() it won't try to disconnect the host again in a loop
			for(var/datum/phone/member in members)
				member.onRemoteDisconnect(host) // we only wanna play this once per person
			dispose() // the phonecall can't exist if we stop hosting!
		else
			pendingMembers -= target
			members -= target
			if(!disposing)
				for(var/datum/phone/member in members)
					member.onRemoteDisconnect(target)
				host.onRemoteDisconnect(target)


	/// Returns a list of all members of a call, including its host
	proc/getMembers()
		var/memberList = list()
		memberList += members
		memberList += host
		return memberList



	/// Relays incoming speech from call members to the rest of the members in the call
	proc/relaySpeech(var/datum/phone/source, mob/M as mob, text, secure, real_name, lang_id)
		for(var/datum/phone/target in getMembers())
			target.speechReceived(source, M, text, secure, real_name, lang_id)


	/// Handles relaying dials to other members of a call. By default this has no effect, but may find use in machine-linked phone systems
	proc/relayDial(var/datum/phone/source, var/key)
		var/recipients = list()
		recipients += getMembers()
		recipients -= source
		for(var/datum/phone/target in recipients)
			target.receiveDial(source, key)

	/// The coolest proc, responsible for routing the reagents to the various onVape() procs for phone members where canVape is true. Returns the # of phones successfully vaped into
	proc/relayVape(var/obj/item/reagent_containers/vape/vape, var/mob/living/sourceMob, var/datum/phone/sourcePhone) // doing this to group calls is a terrible idea :)
		. = 0 // how many people did we prank with our sick vape??
		if((sourcePhone != host) && !(sourcePhone in members))
			return
		var/recipients = getMembers()
		recipients -= sourcePhone
		for(var/datum/phone/target in recipients)
			if(!target.canVape)
				recipients -= target

		if(!length(recipients))
			return

		vape.reagents.trans_to(sourceMob, 5)

		var/amountToTransfer = 5 / length(recipients)

		for(var/datum/phone/target in recipients)
			var/datum/reagents/buffer = new /datum/reagents(5)
			buffer.my_atom = vape // honestly just copy/pasted this since im not too familiar with reagent code oops
			vape.reagents.trans_to_direct(buffer, amountToTransfer)
			target.onVape(buffer, vape, sourceMob, sourcePhone)
			.++


	/// Attempts to find a valid voltron target in all members of a call and will return the target phone datum if successful, as well as if a Mishap occurs
	proc/getVoltronTarget(var/mob/user, var/obj/item/device/voltron/voltron, var/datum/phone/source)
		if((source != host) && !(source in members))
			return
		var/recipients = getMembers()
		recipients -= source
		for(var/datum/phone/target in recipients)
			if(!target.canVoltron)
				recipients -= target
		if(!length(recipients))
			return
		var/returnList = list()
		var/datum/phone/target = pick(recipients)
		returnList += target

		if(prob(5) && (length(recipients) > 1)) // try not to roll a nat 1, nerd. at least in group calls.
			recipients -= target
			returnList += pick(recipients) // 2nd index indicates which phone part of the voltron nerd's body is going to
		else
			returnList += FALSE

		return returnList

/datum/phone/test

	speechReceived(var/datum/phone/source, mob/M as mob, text, secure, real_name, lang_id)
		var/obj/item/testPhone/ourHolder = holder
		ourHolder.outputSpeech(source, M, text, secure, real_name, lang_id)

/obj/item/testPhone
	name = "TEST PHONE"
	desc = "PHONE!!"
	icon = 'icons/obj/cellphone.dmi'
	icon_state = "cellphone-on"
	flags = TALK_INTO_HAND
	var/datum/phone/test/phoneDatum = null
	var/datum/tgui/ui = null

	New()
		..()
		phoneDatum = new(src)

	attack_self(mob/user)
		. = ..()
		ui = phoneDatum.ui_interact(user, ui)

	talk_into(mob/M as mob, text, secure, real_name, lang_id)
		phoneDatum.sendSpeech(M, text, secure, real_name, lang_id)

	proc/outputSpeech(var/datum/phone/source, mob/M as mob, text, secure, real_name, lang_id)
		var/mob/user
		if(!istype(src.loc, /mob))
			return
		user = src.loc
		//var/processed = "<span class='game say'><span class='bold'>[M.name]</span> says, <span class='message'>\"[text[1]]\"</span></span>"
		user.show_message(text, 2)

/obj/item/testPhone/testPhone2
	name = "TEST PHONE 2"

/obj/item/testPhone/testPhone3
	name = "TEST PHONE 3"
