#define EXTERNAL_LINK(URL, TEXT) {"<a href=""} + URL + {"" target="_blank">"} + TEXT + {"</a>"}

/proc/trim_left(text)
	for (var/i = 1 to length(text))
		if (text2ascii(text, i) > 32)
			return copytext(text, i)
	return ""

/proc/trim_right(text)
	for (var/i = length(text) to 1 step -1)
		if (text2ascii(text, i) > 32)
			return copytext(text, 1, i + 1)

	return ""

/proc/startswith(text, start)
	if(length(text) < length(start))
		return FALSE
	return copytext(text, 1, length(start) + 1) == start

/proc/endswith(text, end)
	if(length(text) < length(end))
		return FALSE
	return copytext(text, length(text) - length(end) + 1, length(text) + 1) == end

#define is_uppercase_letter(c) (text2ascii(c, 1) >= 65 && text2ascii(c, 1) <= 90)
#define is_lowercase_letter(c) (text2ascii(c, 1) >= 97 && text2ascii(c, 1) <= 122)

var/list/uppercase_letters = list("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z")
var/list/lowercase_letters = list("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z")

/proc/capitalize(var/t as text)
	var/code = text2ascii(t,1)

	// Check if it isn't between a-z before uppertexting it
	if (code < 97 || code > 122)
		return t

	return uppertext(copytext(t, 1, 2)) + copytext(t, 2)

/proc/capitalize_each_word(t as text)
	var/list/split = splittext(t, " ")
	var/list/words = list()
	for (var/word in split)
		words += capitalize(word)
	return list2text(words, " ")

/// Returns true if the given string has a vowel
/proc/isVowel(var/t as text)
	return findtextEx(lowertext(t), "aeiouåäö") > 0

/**
  * Returns true if given string is just space characters
  * The explicitly defined entries are various blank unicode characters that don't get included as white space by \s
  */
var/global/regex/is_blank_string_regex = new(@{"^(\s|[\u00A0\u00AC\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u200C\u200D\u200E\u200F\u2011\u2028\u2029\u202A\u202B\u202C\u202D\u202E\u202F\u205F\u2060\u2066\u2067\u2068\u2069\u206A\u206B\u206C\u206D\u206E\u206F\u3000])*$"})
#define is_blank_string(txt) is_blank_string_regex.Find(txt)

var/global/regex/discord_emoji_regex = new(@{"(?:<|&lt;)(?:a)?:([-a-zA-Z0-9_]+):(\d+)(?:>|&gt;)"}, "g")
/proc/discord_emojify(text)
	return discord_emoji_regex.Replace(text, {"<img src="https://cdn.discordapp.com/emojis/$2.gif" onerror="if (this.src != 'https://cdn.discordapp.com/emojis/$2.png') this.src = 'https://cdn.discordapp.com/emojis/$2.png';" title="$1" width="32" height="32">"})

/proc/linkify(text)
	. = text
	while(full_url_regex.Find(text))
		var/http_part = full_url_regex.group[1]
		if(length(http_part) == 0)
			http_part = "http://"
		var/full_url = http_part + full_url_regex.group[2]
		. = replacetext(., full_url_regex.match, "<a target='_blank' href='[full_url]'>[full_url_regex.match]</a>")

/// Generates a random Unicode emoji that will look ok in the chat
/proc/random_emoji()
	// source for ranges: https://stackoverflow.com/questions/30470079/emoji-value-range
	return ascii2text(pick(
		1; 0x00A9,
		1; 0x00AE,
		1; 0x203C,
		1; 0x2049,
		1; 0x20E3,
		1; 0x2122,
		1; 0x2139,
		(0x2199 - 0x2194 + 1); rand(0x2194, 0x2199),
		(0x21AA - 0x21A9 + 1); rand(0x21A9, 0x21AA),
		1; 0x231A,
		1; 0x231B,
		1; 0x2328,
		1; 0x23CF,
		(0x23F3 - 0x23E9 + 1); rand(0x23E9, 0x23F3),
		(0x23FA - 0x23F8 + 1); rand(0x23F8, 0x23FA),
		1; 0x24C2,
		1; 0x25AA,
		1; 0x25AB,
		1; 0x25B6,
		1; 0x25C0,
		(0x25FE - 0x25FB + 1); rand(0x25FB, 0x25FE),
		(0x27EF - 0x2600 + 1); rand(0x2600, 0x27EF),
		1; 0x2934,
		1; 0x2935,
		(0x2BFF - 0x2B00 + 1); rand(0x2B00, 0x2BFF),
		1; 0x3030,
		1; 0x303D,
		1; 0x3297,
		1; 0x3299,
		(0x1F02F - 0x1F000 + 1); rand(0x1F000, 0x1F02F),
		(0x1F0FF - 0x1F0A0 + 1); rand(0x1F0A0, 0x1F0FF),
		(0x1F64F - 0x1F100 + 1); rand(0x1F100, 0x1F64F),
		(0x1F6FF - 0x1F680 + 1); rand(0x1F680, 0x1F6FF),
		(0x1F96B - 0x1F910 + 1); rand(0x1F910, 0x1F96B),
		(0x1F9E0 - 0x1F980 + 1); rand(0x1F980, 0x1F9E0)
		))


/// Takes a hash generated by md5() and turns it into a string of alternating consonants and vowels
proc/md5_to_more_pronouncable(text)
	// not actually all consonants, only those that tend to make good sounding things
	var/list/consonants = list("b", "c", "d", "f", "g", "h", "k", "l", "m", "n", "p", "r", "s", "t", "v", "w", "z")
	var/list/vowels = list("a", "e", "i", "o", "u")
	. = list()
	for(var/i in 1 to length(text) step 2)
		var/num = text2num(copytext(text, i, i + 2), 16) % (length(consonants) * length(vowels))
		. += consonants[num % length(consonants) + 1]
		. += vowels[round(num / length(consonants)) + 1]
	. = jointext(., "")

/**
 * Removes a given prefix from a string.
 *
 * @return The string without the prefix if the prefix was present at the start. If not, the original string is returned.
 *
 * Note: Non-text inputs will be converted into a string. The procedure is case sensitive.
 */
proc/strip_prefix(string, prefix)
	if (!istext(string))
		string = "[string]"
	if(copytext(string, 1, length(prefix) + 1) == prefix)
		string = copytext(string, length(prefix) + 1)
	return string

proc/strip_prefix_from_list(list/L, prefix)
	for(var/i in 1 to length(L))
		if(copytext(L[i], 1, length(prefix) + 1) == prefix)
			L[i] = copytext(L[i], length(prefix) + 1)

proc/get_longest_common_prefix(list/L)
	if(!length(L))
		return ""
	. = L[1]
	for(var/i in 2 to length(L))
		var/cur = L[i]
		var/len = min(length(.), length(cur))
		for(var/j in len to 1 step -1)
			if(copytext(., 1, j + 1) == copytext(cur, 1, j + 1))
				if(j < length(.))
					. = copytext(., 1, j + 1)
				break

/// Returns a string with all HTML special characters encoded and newlines replaced with <br>
proc/newline_html_encode(text)
	return replacetext(html_encode(text), "\n", "<br>")

/// Returns a string with all HTML special characters decoded and <br> replaced with newlines
proc/newline_html_decode(text)
	return html_decode(replacetext(text, "<br>", "\n"))

proc/pluralize(word)
	. = word
	if(endswith(., "s") || endswith(., "ch") || endswith(., "sh") || endswith(., "z") || endswith(., "x"))
		. += "es"
	else
		. += "s"

proc/list2text(L, d = "")
	return jointext(L, d)


// DM simultaneously makes cursed shit like this work...
// yet won't work with just the unicode raws - infinite pain
var/const/___proper = "\proper"
var/const/___improper = "\improper"
var/static/regex/regexTextMacro = regex("[___proper]|[___improper]", "g")

/**
  * Removes the special data inserted via use of \improper etc in strings
  */
#define stripTextMacros(text) replacetext(text, regexTextMacro, "")

var/global/regex/sentence_end_regex = regex(".*\[\\.\\?\\!\\-\]$")
proc/end_sentence(sentence, punctuation = ".")
	if (sentence_end_regex.Find(sentence))
		return sentence
	return sentence + punctuation

/// Replace all instances of a char, with consecutive chars all replaced only once (Ex: "?xxx?xx?x?" => "?y?y?y?"). Useful for parsing.
proc/text_replace_repeat(var/text, var/target_char, var/replacement)
	var/new_text = ""
	var/is_repeat = FALSE
	for(var/i in 1 to length(text))
		var/char = copytext(text, i, i+1)
		if(char == target_char)
			if(is_repeat)
				continue
			new_text += replacement
			is_repeat = TRUE
		else
			new_text += char
			is_repeat = FALSE
	return new_text

/// Return true if the text contains any of the specified characters.
proc/contains_chars(var/text, var/list/other_chars, var/include_nums = FALSE, var/include_letters = FALSE)
	for(var/i in 1 to length(text))
		var/input_char = copytext(text, i, i+1)
		if(include_nums && text2num_safe(input_char))
			return TRUE
		if(include_letters && (is_uppercase_letter(input_char) || is_lowercase_letter(input_char)))
			return TRUE
		if(other_chars)
			for(var/char in other_chars)
				if(input_char == char)
					return TRUE
	return FALSE

/// Remove any characters in the text that are not listed
proc/limit_chars(var/text, var/list/other_chars, var/include_nums = FALSE, var/include_letters = FALSE)
	var/new_text = ""
	for(var/i in 1 to length(text))
		var/input_char = copytext(text, i, i+1)
		if(include_nums && text2num_safe(input_char))
			new_text += input_char
		else if(include_letters && (is_uppercase_letter(input_char) || is_lowercase_letter(input_char)))
			new_text += input_char
		else
			for(var/char in other_chars)
				if(input_char == char)
					new_text += input_char
					break
	return new_text

/// Checks if the two text strings are equal, but ignore a specific character
proc/text_equals_partial(var/textA, var/textB, var/ignore_char = "?")
	if(length(textA) != length(textB))
		return FALSE
	for(var/i in 1 to length(textA))
		var/charA = copytext(textA, i, i+1)
		var/charB = copytext(textB, i, i+1)
		if(charA != ignore_char && charB != ignore_char && charA != charB)
			return FALSE
	return TRUE

/// Return true if the text contained in needles appears in haystack in the same order
proc/findtextEx_ordered(var/haystack, var/list/needles)
	if(length(needles) == 0)
		return TRUE
	if(length(needles) == 1)
		return findtextEx(haystack, needles[1])
	var/list/needle_index = list()
	needle_index += findtextEx(haystack, needles[1])
	for(var/i in 2 to length(needles))
		needle_index += findtextEx(haystack, needles[i], needle_index[i-1] + length(needles[i-1]))
	for(var/pos in needle_index)
		if(pos == 0)
			return FALSE
	return TRUE
